<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="description" content="WebXR">
    <meta name="author" content="Mio">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <title>Three.js Web App Test</title>
    <style> /*-- will be removed when link added for css --*/
    body {
        margin: 0;
    }
    </style>
</head>
<body>
<script src="js/three.js"></script>
<script type="module">
    import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
    import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js";
    import { STLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/loaders/STLLoader.js';

    var mesh,
        renderer,
        scene,
        camera,
        controls,
        geometry,
        cubes,
        points,
        lineGeometry,
        material,
        line,
        gtlfLoader;

    let gltfLoader = new GLTFLoader();
    let stlLoader = new STLLoader()

    init();
    animate();

    function init() {
        //=================//
        // Create a scene ||
        //=================//

        // -- scene: parent obj where all rendered obj, lights, and cameras live
        scene = new THREE.Scene();

        // -- camera: obj allows us to see other obj
        // Parameters:
        // FOV - Field of View - number in degrees representing vertical field of view - up down
        // Aspect Ratio: ratio between width and height (width divided by height) - innerWidth/Height grabs window size
        // Near Clipping Plane: plane closest to the camera - current val is max - anything closer and nothing is rendered
        // Far Clipping Plane: plane furtherst from camera - current val is max - anything bigger and nothing will be rendered
        // setting far clipping to be =< near clipping then nothing will be rendered
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight,
            0.6, 1200);
        camera.position.z = 5; // change camera position from z axis

        // -- renderer: obj renders scene using WebGL
        renderer = new THREE.WebGLRenderer({antialias: true});

        // set color of bg in hex - 0-1 can be set for alpha - opacity
        renderer.setClearColor("#233143");
        // sets size of app
        renderer.setSize(window.innerWidth, window.innerHeight);
        // appends renderer to html doc as canvas to draw in browser
        document.body.appendChild(renderer.domElement);

        // -- controls: allows mouse controls such as click+drag, zoom, etc.
        // Add mouse controls
        controls = new OrbitControls( camera, renderer.domElement );

        // -- gtlf: load gtlf object resource
        // loadGltf();

        // -- stl: load spacecraft stl object resource
        loadSpacecraft();

        // visible axes for x,y,z planes
        // TODO: remove later
        scene.add( new THREE.AxesHelper( 150 ) );

        // Responsive Design //
        // allow for window resizing //
        window.addEventListener('resize', () => { // if window is resized
            renderer.setSize(window.innerWidth, window.innerHeight); // identify new win size
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // apply new changes to new win size
        })

        // --- creating box --- //
        geometry = new THREE.BoxGeometry(); // width, height, depth

        // create array of cubes using function makeCube above
        // cubes = [
        //     makeCube(geometry, 0x44aa88, 0),
        //     makeCube(geometry, 0x8844aa, -2),
        //     makeCube(geometry, 0xaa8844, 2),
        // ];

        //---- CREATE LINE ----//
        points = [];
        points.push(new THREE.Vector3(-10, 0, 0));
        points.push(new THREE.Vector3(0, 10, 0));
        points.push(new THREE.Vector3(10, 0, 0));
        // add points to create lines
        //----- DRAWING LINE ---//
        lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        material = new THREE.MeshLambertMaterial(0xFFFFFF);
        line = new THREE.Line(lineGeometry, material);
        //scene.add(line); // add line to scene
        //scene.add(line);
        //----- ADDING LIGHTING EFFECTS ---//
        {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1, 2, 4);
            scene.add(light);
        }
    }

    // render scene
    // animation loop
    // redraw scene 60FPS
    // keep function at bottom
    // needs to reference the above definitions
    function animate() {

        // Rotate scene constantly
        // uncomment these lines to see rotation in action.
        //scene.rotation.z -= 0.005;
        //scene.rotation.x -= 0.01;

        renderer.render(scene, camera);
        requestAnimationFrame(animate); // recursive call to animate function
    }

    function loadGltf() {
        // -- gltf: Load a gltf resource file
        // Instantiate a loader
        //gltfLoader = new GLTFLoader();
        // Load a glTF resource
        gltfLoader.load(
            // resource URL
            '../src/res/gltf/cube/Cube.gltf',
            // called when the resource is loaded
            function ( gltf ) {
                scene.add( gltf.scene );

                gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Group
                gltf.scenes; // Array<THREE.Group>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object
            },
            // called while loading is progressing
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened' );
            }
        );
    }

    function loadSpacecraft() {

        const material = new THREE.MeshPhysicalMaterial({
            color: 0xb2ffc8,
            //envMap: envTexture,
            metalness: 0.25,
            roughness: 0.1,
            //opacity: 2,
            transparent: false,
            transmission: 0.99,
            clearcoat: 1.0,
            clearcoatRoughness: 0.25
        })

        stlLoader.load(
            '../src/res/stl/spacecraft/spacecraft_panels_antenna_attached.stl',
            function (geometry) {
                const mesh = new THREE.Mesh(geometry, material)

                // change these values to modify the x,y,z plane that this model sits on when it is loaded.
                mesh.rotation.set(-Math.PI / 2, 0,  Math.PI / 2);
                scene.add(mesh)
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            },
            (error) => {
                console.log(error)
            }
        )
    }

    function makeCube(geometry, color, x) {
        const material = new THREE.MeshPhongMaterial({color});
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube); // added box at (0,0)

        cube.position.x = x;

        return cube;
    }

    // check for XR support
    // not working..... need to debug..
    async function checkForXRSupport() {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            if (supported) {
                var enterXrBtn = document.createElement("button");
                enterXrBtn.innerHTML = "Enter Ar";
                enterXrBtn.addEventListener("click", beginXRSession);
                document.body.appendChild(enterXrBtn);
            } else {
                console.log("Session not supported: " + reason);
            }
        });
    }

    function beginXRSession() {
        // requestSession must be called within a user gesture event
        // like click or touch when requesting an immersive session.
        navigator.xr.requestSession('immersive-vr')
            .then(onSessionStarted)
            .catch(err => {
                // May fail for a variety of reasons. Probably just want to
                // render the scene normally without any tracking at this point.
                window.requestAnimationFrame(onDrawFrame);
            });
    }
</script>
</body>
</html>