<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="description" content="WebXR">
    <meta name="author" content="Mio">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <title>Three.js Web App Test</title>
    <style> /*-- will be removed when link added for css --*/
        body { margin: 0; }
    </style>
</head>
<body>
<script src="js/three.js"></script>
<script>

    //=================//
    // Create a scene ||
    //=================//

    // -- scene: parent obj where all rendered obj, lights, and cameras live
    const scene = new THREE.Scene();

    // -- camera: obj allows us to see other obj
    // Parameters:
    // FOV - Field of View - number in degrees representing vertical field of view - up down
    // Aspect Ratio: ratio between width and height (width divided by height) - innerWidth/Height grabs window size
    // Near Clipping Plane: plane closest to the camera - current val is max - anything closer and nothing is rendered
    // Far Clipping Plane: plane furtherst from camera - current val is max - anything bigger and nothing will be rendered
    // setting far clipping to be =< near clipping then nothing will be rendered
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight,
        0.6, 1200);
    camera.position.z = 5; // change camera position from z axis

    // -- renderer: obj renders scene using WebGL
    const renderer = new THREE.WebGLRenderer({antialias: true});

    // set color of bg in hex - 0-1 can be set for alpha - opacity
    renderer.setClearColor("#233143");
    // sets size of app
    renderer.setSize(window.innerWidth, window.innerHeight);
    // appends renderer to html doc as canvas to draw in browser
    document.body.appendChild(renderer.domElement);

    // Responsive Design //
    // allow for window resizing //
    window.addEventListener('resize', () => { // if window is resized
        renderer.setSize(window.innerWidth,window.innerHeight); // identify new win size
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix(); // apply new changes to new win size
    })

    // check for XR support
    // not working..... need to debug..
    async function  checkForXRSupport() {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            if(supported) {
                var enterXrBtn = document.createElement("button");
                enterXrBtn.innerHTML = "Enter Ar";
                enterXrBtn.addEventListener("click", beginXRSession);
                document.body.appendChild(enterXrBtn);
            } else {
                console.log("Session not supported: " + reason);
            }
        });
    }

    // --- creating box --- //
    const geometry = new THREE.BoxGeometry(); // width, height, depth
    const material = new THREE.MeshLambertMaterial({color:0xFFFFFF}); // box material - white
    const cube = new THREE.Mesh( geometry, material );
    scene.add(cube); // added box at (0,0)

    const points = [];
    points.push( new THREE.Vector3( - 10, 0, 0 ) );
    points.push( new THREE.Vector3( 0, 10, 0 ) );
    points.push( new THREE.Vector3( 10, 0, 0 ) );
    // add points to create lines
    const lineGeometry = new THREE.BufferGeometry().setFromPoints( points );
    // craete line using the points and the materai defined above for box
    const line = new THREE.Line( lineGeometry, material );
    scene.add(line); // add line to scene

    // render scene
    // animation loop
    // redraw scene 60FPS
    // keep function at bottom
    // needs to reference the above definitions
    function animate() {
        requestAnimationFrame( animate ); // recursive call to animate function

        // Rotate box constantly
        scene.rotation.z -= 0.005;
        scene.rotation.x -= 0.01;
        renderer.render( scene, camera );
    }
    animate();
</script>
</body>
</html>